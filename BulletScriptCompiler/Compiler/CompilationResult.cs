using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Atrufulgium.BulletScript.Compiler {
    /// <summary>
    /// Contains the result of compilation:
    /// <list type="bullet">
    /// <item>
    /// If <see cref="Succesful"/>, contains the resulting <see cref="BytecodeOutput"/>.
    /// This output can be requested with <see cref="TryGetBytecodeOutput(out BytecodeOutput)"/>.
    /// </item>
    /// <item>
    /// <see cref="Diagnostics"/> are always included, and may help discover
    /// why the compilation failed, if unsuccesful.
    /// </item>
    /// </list>
    /// </summary>
    public class CompilationResult {
        /// <summary>
        /// Whether compilation succeeded.
        /// </summary>
        public bool Succesful => Bytecode != null;
        internal BytecodeOutput? Bytecode { get; set; }

        /// <summary>
        /// All warnings and errors encountered during compilation.
        /// </summary>
        public ReadOnlyCollection<Diagnostic> Diagnostics { get; internal set; }

        internal CompilationResult(IList<Diagnostic> diagnostics)
            => Diagnostics = new(diagnostics);
        internal CompilationResult(IList<Diagnostic> diagnostics, BytecodeOutput bytecode)
            : this(diagnostics)
            => Bytecode = bytecode;

        /// <summary>
        /// If compilation was succesful, returns the generated bytecode
        /// in <paramref name="output"/>.
        /// </summary>
        public bool TryGetBytecodeOutput([NotNullWhen(true)] out BytecodeOutput? output) {
            output = null;
            if (Bytecode == null)
                return false;
            output = Bytecode;
            return true;
        }

        /// <summary>
        /// Returns a neat representation of all diagnostics.
        /// </summary>
        public string PrettyprintDiagnostics() {
            var order = new SortedSet<Diagnostic>(
                Comparer<Diagnostic>.Create((d1, d2) => {
                    // Order (Level, ID, Location)
                    // Errors should come on top
                    var compareErrors = -d1.DiagnosticLevel.CompareTo(d2.DiagnosticLevel);
                    if (compareErrors != 0) return compareErrors;

                    var compareID = d1.ID.CompareTo(d2.ID);
                    if (compareID != 0) return compareID;

                    return d1.Location.ToString().CompareTo(d2.Location.ToString());
                })
            );

            foreach (var d in Diagnostics) {
                order.Add(d);
            }

            return string.Join('\n', order.Select(d => d.ToString()));
        }
    }
}
