#nullable disable // Monobehaviour start instead of constructor
using Atrufulgium.BulletScript.Compiler;
using Atrufulgium.EternalDreamCatcher.Base;
using Atrufulgium.EternalDreamCatcher.BulletEngine;
using Atrufulgium.EternalDreamCatcher.BulletEngine.TickStrategies;
using Atrufulgium.EternalDreamCatcher.BulletScriptVM;
using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.UI;

namespace Atrufulgium.EternalDreamCatcher.Game {

    [RequireComponent(typeof(Camera))]
    public class DanmakuSceneBehaviour : MonoBehaviour {

        DanmakuScene danmakuScene;
        [Min(1)]
        public int TicksPerTick = 1;

        public Material bulletMaterial;
        public Material entityMaterial;
        // Assign this the default quad.
        // Note to self: it has vertices (Å}0.5f,Å}0.5f).
        public Mesh quadMesh;
        new Camera camera;

        CommandBuffer buffer;

        public RawImage target;
        RenderTexture texture;

        public Texture2D[] bulletTextures;
        public Texture2D[] entityTextures;

        int tempRTid;

        NativeReference<Player> player;

        List<IDisposable> testDisposables = new();

        public enum TickStrategy {
            Separated = 0,
            Parallizable = 1,
            MegaJob = 2
        }
        public TickStrategy tickStrategy = TickStrategy.Separated;
        public bool limitJobWorkerCount = true;

        void Start() {
            if (bulletMaterial == null) throw new System.NullReferenceException();
            if (quadMesh == null) throw new System.NullReferenceException();
            if (bulletTextures == null || bulletTextures.Length == 0) throw new System.NullReferenceException();

            // TODO: Put this someplace better
            Application.targetFrameRate = 60;

            player = new(new() {
                position = new(0.5f, 1.1f),
                remainingLives = 3,
                RemainingBombs = 2,
                focusedSpeed = 0.25f / 60,
                unfocusedSpeed = 0.66f / 60,
                hitboxRadius = 0.005f,
                grazeboxRadius = 0.025f
            }, Allocator.Persistent);

            danmakuScene = new DanmakuScene(
                quadMesh, bulletMaterial, bulletTextures, entityMaterial, entityTextures,
                player,
                new TickStrategySeparated()
            );
            UpdateStrategy();

            var vm = CreateVM();
            if (vm.IsCreated)
                danmakuScene.activeVMs.Add(vm);

            camera = GetComponent<Camera>();

            tempRTid = Shader.PropertyToID("_tempFieldRendererRT");

            var size = BulletFieldRenderer.GetBulletFieldResolution();
            texture = new(size.x, size.y, 0);
            target.texture = texture;
        }

        unsafe VM CreateVM() {
            NativeReference<Unity.Mathematics.Random> rngRef = new(new(230), Allocator.Persistent);
            NativeReference<uint> uintRef = new(0, Allocator.Persistent);

            var compilation = Compiler.Compile(@"
float t;
spawnspeed = 0.12f;
spawnposition = [0.5; 0.5];
repeat {
    t += 0.025f;
    spawnrotation += sin(t) + 0.25f;
    spawn();
    spawnrotation += 0.25f;
    spawn();
    spawnrotation += 0.25f;
    spawn();
    spawnrotation += 0.25f;
    spawn();
    wait(5);
}
");
            if (!compilation.TryGetBytecodeOutput(out var output)) {
                Debug.LogError(compilation.PrettyprintDiagnostics());
                return default;
            } else if (compilation.Diagnostics.Count > 0) {
                Debug.LogWarning(compilation.PrettyprintDiagnostics());
                return default;
            }
            Debug.Log("Generated bytecode:\n" + output.ToString());
            LLOP[] opcodes = output.OpCodes;
            VM vm = new(
                // This won't bite me in the arse
                UnsafeUtility.As<LLOP[], float4[]>(ref opcodes),
                output.Memory.Length,
                output.Memory.Length, // temp
                output.Strings,
                default,
                uintRef.GetUnsafeTypedPtr(),
                rngRef.GetUnsafeTypedPtr()
            );
            testDisposables.Add(rngRef);
            testDisposables.Add(uintRef);
            testDisposables.Add(vm);
            return vm;
        }

        JobHandle currentUpdate;
        private void Update() {
            // (This does nothing with `default`, and does not throw.)
            currentUpdate.Complete();

            // Add current tick's input
            // TODO: only if not in replay mode.
            var input = new GameInput(
                (Input.GetKey(KeyCode.LeftArrow) ? new int2(-1, 0) : default)
                + (Input.GetKey(KeyCode.RightArrow) ? new int2(1, 0) : default)
                + (Input.GetKey(KeyCode.UpArrow) ? new int2(0, -1) : default)
                + (Input.GetKey(KeyCode.DownArrow) ? new int2(0, 1) : default),
                Input.GetKey(KeyCode.Z),
                Input.GetKeyDown(KeyCode.X),
                Input.GetKey(KeyCode.LeftShift)
            );
            for (int i = 0; i < TicksPerTick; i++) {
                danmakuScene.input.Add(input);
            }

            currentUpdate = danmakuScene.ScheduleTick(TicksPerTick);
            // Note: Do not be tempted by JobHandle.ScheduleBatchedJobs().
            // Even with the gap between the end of this Update() and the start
            // of the jobs, not having it is faster. idk why.
            // Adding that call removes the gap but has more overhead.
            // (Unless that overhead was specifically because I x1200'd, with
            //  "reasonable" values it helps, if only by É s's?)
            // Funny thing though: this is one of the rare cases in which the
            // code in the editor profiles __faster__. Because the ~2.50ms
            // EditorLoop is also used for the jobs stuff on other threads.
            // (Okay that's about it wrt this call.)
            JobHandle.ScheduleBatchedJobs();
        }

        private void OnPreRender() {
            currentUpdate.Complete();
            SetBuffer();
        }

        private void OnDestroy() {
            // TODO: Remove once not testing anymore
            foreach (var d in testDisposables)
                d.Dispose();
            danmakuScene.Dispose();
            buffer.Dispose();
            player.Dispose();
        }

        private void OnValidate() {
            UpdateStrategy();
        }

        private void SetBuffer() {
            if (buffer == null) {
                buffer = new() { name = "BulletFieldRendering" };
            } else {
                // Gets re-added anyways
                camera.RemoveCommandBuffer(CameraEvent.AfterEverything, buffer);
                buffer.Clear();
            }

            var size = BulletFieldRenderer.GetBulletFieldResolution();
            buffer.GetTemporaryRT(tempRTid, size.x, size.y);
            buffer.SetRenderTarget(new RenderTargetIdentifier(tempRTid));
            buffer.ClearRenderTarget(true, true, Color.black, 0);

            danmakuScene.Render(buffer);

            buffer.Blit(tempRTid, texture);

            // Canvas is drawn on top of "everything".
            camera.AddCommandBuffer(
                CameraEvent.AfterEverything,
                buffer
            );
        }

        private void UpdateStrategy() {
            if (danmakuScene == null)
                return;

            danmakuScene.TickStrategy = tickStrategy switch {
                TickStrategy.Separated => new TickStrategySeparated(),
                TickStrategy.Parallizable => new TickStrategyParallizable(),
                TickStrategy.MegaJob => new TickStrategyMegaJob(),
                _ => throw new ArgumentException("Invalid tick strategy.")
            };

            // Multithreaded synchronisation has overhead.
            // Setting JobWorkerCount to 0 removes this overhead.
            // Only the entire ticks strategy doesn't suffer from this overhead
            // (as it's just one job).
            if (limitJobWorkerCount)
                JobsUtility.JobWorkerCount = 0;
            else
                JobsUtility.ResetJobWorkerCount();
        }
    }
}
