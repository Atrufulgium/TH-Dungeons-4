#nullable disable // Monobehaviour start instead of constructor
using Atrufulgium.BulletScript.Compiler;
using Atrufulgium.EternalDreamCatcher.Base;
using Atrufulgium.EternalDreamCatcher.BulletEngine;
using Atrufulgium.EternalDreamCatcher.BulletScriptVM;
using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.UI;

namespace Atrufulgium.EternalDreamCatcher.Game {

    [RequireComponent(typeof(Camera))]
    public class DanmakuSceneBehaviour : MonoBehaviour {

        NativeReference<KeyboardInput> gameInput;
        DanmakuScene danmakuScene;
        [Min(1)]
        public int TicksPerTick = 1;

        public Material bulletMaterial;
        public Material entityMaterial;
        // Assign this the default quad.
        // Note to self: it has vertices (Å}0.5f,Å}0.5f).
        public Mesh quadMesh;
        new Camera camera;

        CommandBuffer buffer;

        public RawImage target;
        RenderTexture texture;

        public Texture2D[] bulletTextures;
        public Texture2D[] entityTextures;

        int tempRTid;

        NativeReference<Player> player;

        List<IDisposable> testDisposables = new();

        void Start() {
            if (bulletMaterial == null) throw new System.NullReferenceException();
            if (quadMesh == null) throw new System.NullReferenceException();
            if (bulletTextures == null || bulletTextures.Length == 0) throw new System.NullReferenceException();

            // TODO: Put this someplace better
            Application.targetFrameRate = 60;
            // TODO: Stop using Unity lmao, if the multithreading model is
            // incompatible with what I throw at it, the Burst compiler can
            // viably be replaced with modern .NET features, and I'm doing the
            // rendering myself anyways, is there even anything left to bind
            // me to the engine at this point?
            // Anyways.
            // The overhead of the jobs system is much too much for the stream
            // of tiny tasks I throw at it. Forcing everything on the main
            // thread allows for -- and I'm not kidding -- a ~x10 speedup.
            // With 1/10th of the resources available. Yep.
            JobsUtility.JobWorkerCount = 0;

            player = new(new() {
                position = new(0.5f, 1.1f),
                remainingLives = 3,
                RemainingBombs = 2,
                focusedSpeed = 0.25f / 60,
                unfocusedSpeed = 0.66f / 60,
                hitboxRadius = 0.005f,
                grazeboxRadius = 0.025f
            }, Allocator.Persistent);

            gameInput = new(new(), Allocator.Persistent);

            danmakuScene = new DanmakuScene<KeyboardInput>(quadMesh, bulletMaterial, bulletTextures, entityMaterial, entityTextures, gameInput, player);

            var vm = CreateVM();
            if (vm.IsCreated)
                danmakuScene.activeVMs.Add(vm);

            camera = GetComponent<Camera>();

            tempRTid = Shader.PropertyToID("_tempFieldRendererRT");

            var size = BulletFieldRenderer.GetBulletFieldResolution();
            texture = new(size.x, size.y, 0);
            target.texture = texture;
        }

        unsafe VM CreateVM() {
            NativeReference<Unity.Mathematics.Random> rngRef = new(new(230), Allocator.Persistent);
            NativeReference<uint> uintRef = new(0, Allocator.Persistent);

            var compilation = Compiler.Compile(@"
float t;
spawnspeed = 0.12f;
spawnposition = [0.5; 0.5];
repeat {
    t += 0.025f;
    spawnrotation += sin(t) + 0.25f;
    spawn();
    spawnrotation += 0.25f;
    spawn();
    spawnrotation += 0.25f;
    spawn();
    spawnrotation += 0.25f;
    spawn();
    wait(5);
}
");
            if (!compilation.TryGetBytecodeOutput(out var output)) {
                Debug.LogError(compilation.PrettyprintDiagnostics());
                return default;
            } else if (compilation.Diagnostics.Count > 0) {
                Debug.LogWarning(compilation.PrettyprintDiagnostics());
                return default;
            }
            Debug.Log("Generated bytecode:\n" + output.ToString());
            LLOP[] opcodes = output.OpCodes;
            VM vm = new(
                // This won't bite me in the arse
                UnsafeUtility.As<LLOP[], float4[]>(ref opcodes),
                output.Memory.Length,
                output.Memory.Length, // temp
                output.Strings,
                default,
                uintRef.GetUnsafeTypedPtr(),
                rngRef.GetUnsafeTypedPtr()
            );
            testDisposables.Add(rngRef);
            testDisposables.Add(uintRef);
            testDisposables.Add(vm);
            return vm;
        }

        JobHandle currentUpdate;
        private unsafe void Update() {
            // (This does nothing with `default`, and does not throw.)
            currentUpdate.Complete();

            gameInput.GetUnsafeTypedPtr()->HandleInputMainThread();

            currentUpdate = danmakuScene.ScheduleTick(TicksPerTick);
            // Note: Do not be tempted by JobHandle.ScheduleBatchedJobs().
            // Even with the gap between the end of this Update() and the start
            // of the jobs, not having it is faster. idk why.
            // Adding that call removes the gap but has more overhead.
            // (Unless that overhead was specifically because I x1200'd, with
            //  "reasonable" values it helps, if only by É s's?)
            // Funny thing though: this is one of the rare cases in which the
            // code in the editor profiles __faster__. Because the ~2.50ms
            // EditorLoop is also used for the jobs stuff on other threads.
            // (Okay that's about it wrt this call.)
            JobHandle.ScheduleBatchedJobs();
        }

        private void OnPreRender() {
            currentUpdate.Complete();
            SetBuffer();
        }

        private void OnDestroy() {
            gameInput.Dispose();
            // TODO: Remove once not testing anymore
            foreach (var d in testDisposables)
                d.Dispose();
            danmakuScene.Dispose();
            buffer.Dispose();
            player.Dispose();
        }

        private void SetBuffer() {
            if (buffer == null) {
                buffer = new() { name = "BulletFieldRendering" };
            } else {
                // Gets re-added anyways
                camera.RemoveCommandBuffer(CameraEvent.AfterEverything, buffer);
                buffer.Clear();
            }

            var size = BulletFieldRenderer.GetBulletFieldResolution();
            buffer.GetTemporaryRT(tempRTid, size.x, size.y);
            buffer.SetRenderTarget(new RenderTargetIdentifier(tempRTid));
            buffer.ClearRenderTarget(true, true, Color.black, 0);

            danmakuScene.Render(buffer);

            buffer.Blit(tempRTid, texture);

            // Canvas is drawn on top of "everything".
            camera.AddCommandBuffer(
                CameraEvent.AfterEverything,
                buffer
            );
        }
    }
}
